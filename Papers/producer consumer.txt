public interface MailBox<E>{
public void deposit(E value);
public E retrieve();
}


public class Consumer impmements Runnable{
 private String name;
 private static in ITEM_COUNT;
 private Mailbox<Integer> mailbox;
 
 public Consumer (String name, int ITEM_COUNT, Mailbox<Integer> mailbox){
  this.name = name;
  this.ITEM_COUNT = ITEM_COUNT;
  this.mailbox = mailbox;
 }
 
 public String getName() {return name;}
 
 @Override
 public void run(){
 for (int i = 0; i<ITEM_COUNT; i++){
	mailbox.retrieve();
	System.out.println("COnsumer: "+ Thread.currentThread().getName()+ " consumed"+ i);
	
	/*try{
	Thread.sleep(10);
	} catch (InterruptedException e){
	e.printStackTrace();
	}*/
	}
 }
}


public class Producer impmements Runnable{
 private String name;
 private static in ITEM_COUNT;
 private Mailbox<Integer> mailbox;
 
 public Producer (String name, int ITEM_COUNT, Mailbox<Integer> mailbox){
  this.name = name;
  this.ITEM_COUNT = ITEM_COUNT;
  this.mailbox = mailbox;
 }
 
 public String getName() {return name;}
 
 @Override
 public void run(){
 for (int i = 0; i<ITEM_COUNT; i++){
	mailbox.deopsit();
	System.out.println("COnsumer: "+ Thread.currentThread().getName()+ " consumed"+ i);
	
	/*try{
	Thread.sleep(10);
	} catch (InterruptedException e){
	e.printStackTrace();
	}*/
	}
 }
}


public class SimpleBuffer<E> implements MailBox<E>{

private E content;
private boolean available = false;

@Override
public synchronized void deopsit(E value){
	while(!available){
		try{
		wait();
		} catch (InterruptedException e){
			e.printStackTrace();
		}
		
	this.content = value;
	this.available = true;
	notifyAll();

	}
}

@Override
public synchronized E retrieve{
	while(available){
		try{
		wait();
		} catch (InterruptedException e){
			e.printStackTrace();
		}
		
	
	this.available = false;
	notifyAll();
	return this.content;

	}
}

}



public class MultiSlotMailBox<E> implements MailBox<E>{

private Queue<E> queue = new LinkedList<E>(); //shared variable
    private final int MAX_SIZE = 10;

@Override
public synchronized void deopsit(E value){
	while(queue.size()== MAX_SIZE){
		try{
		wait(5000);
		} catch (InterruptedException e){
			e.printStackTrace();
		}
		
	queue.offer(value);
	notifyAll();

	}
}

@Override
public synchronized E retrieve{
	while(queue.size()== 0){
		try{
		wait(5000);
		} catch (InterruptedException e){
			e.printStackTrace();
		}
		
	
	
	notifyAll();
	return queue.poll;

	}
}

}


import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class MultiSlotMailBoxExpl<E> implements MailBox<E>{

	private Queue<E> queue = new LinkedList<E>(); //shared variable
    private final int MAX_SIZE = 10;
	
	private Lock lock = new ReentrantLock();
    private Condition bufferFull = lock.newCondition();
    private Condition bufferEmpty = lock.newCondition();


@Override
public void deopsit(E value){
lock.lock();
	while(queue.size()== MAX_SIZE){
		try{
		bufferFull.wait();
		} catch (InterruptedException e){
			e.printStackTrace();
		}
		
	queue.offer(value);
	signalAll();

	}
	finally{
	lock.unlock();
	}
}

@Override
public E retrieve{
lock.lock();
	while(queue.size()== 0){
		try{
		bufferEmpty.wait();
		} catch (InterruptedException e){
			e.printStackTrace();
		}
		
	
	
	signalAll();
	return queue.poll;

	}
	finally{
	lock.unlock();
	}
}}


public class MainMultiSlotMailBox {
    public static void main(String[] args) {
        final int noOfItems = 10;
        Mailbox<Integer> multiSlotV1 = new MultiSlotMailBox<Integer>();

        Producer producer = new Producer("Producer", noOfItems, multiSlotV1);
        Producer producer1 = new Producer("Producer1", noOfItems, multiSlotV1);
        Consumer consumer = new Consumer("Consumer", noOfItems, multiSlotV1);
        Consumer consumer1 = new Consumer("Consumer1", noOfItems, multiSlotV1);

        Thread producerThread = new Thread(producer, producer.getName());
        Thread producerThread1 = new Thread(producer1, producer1.getName());
        Thread consumerThread = new Thread(consumer, consumer.getName());
        Thread consumerThread1 = new Thread(consumer1, consumer1.getName());

        producerThread.start();
        producerThread1.start();
        consumerThread.start();
        consumerThread1.start();
    }
}